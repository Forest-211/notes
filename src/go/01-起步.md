# 起步

## 源代码与程序

- 以`.go`为文件后缀，所有`go`文件存放在包中，一个包由一个或者多个go文件组成
- 使用`package`关键字声明当前go文件属于那个包
- 使用`import`关键字引入外部包
- main是一个特殊的包，它定义了一个独立的可执行程序；在`main`包中，`main`函数又是一个特殊的函数

## 变量

> 变量是对一块内存的命名，程序可以通过定义变量来申请一块内存，通过引用变量来使用这块内存

### Go语言中的25个关键字
  
```go
// 包相关 
import、package

// 声明相关
var、const、type、struct、interface、func、chan、map、go

// 循环相关
for、range

// 条件判断相关
if、else、switch、select、case

// 中断或返回
return、goto、fallthrough、break、default、continue

// 延迟执行
defer
```

### 内置的预声明的常量、类型和函数

```go
// 常量
true、false、iota、nil

// 整型
int、int8、int16、int32、int64

// 无符号整型
uint、uint8、uint16、uint32、uint64、uintptr

// 浮点型
float32、float64、complex64、complex128

// 其他
bool、byte、rune、string、error

// 函数
make、len、cap、new、append、copy、close、delete、complex、real、imag、panic、recover
```

### 变量的作用域

- 变量以大写开头字母的表示可导出，对包外是可见、可访问的；以小写字母开头则只能在当前包内使用
- 使用var关键字来创建某种类型的变量并设置初始值；类型和初始值可以省略一个，但是不能同时都省略；当省略初始值时，变量的值默认为当前类型的零值；比如：`int`类型就是0、`boolean`类型就是false、字符串就是" "、接口和应用类型的零值为`nil`、数组和结构体的零值就是所有成员的零值。

### 短变量

- 使用 `:=` 声明变量及赋值；比如:

```go
name := "Forest"
```

- 这种方式声明的变量只能在函数内部使用

### 声明周期

- 声明周期就是程序运行时被程序其他部分所引用的起止时间
- 变量的声明周期是指在程序执行过程中变量存在的时间段

  - 全局变量：包级别变量的声明周期是整个程序的执行时间
  - 局部变量：局部变量的声明周期是动态的，函数的参数和返回值都是局部变量；即函数被调用时被创建，结束后被销毁

- 当创建的变量内存不确定时，会分配给堆；如：切片(slice)、字典(map)、通道(channel)等。如果分配的内存超过栈(stack)的大小，则会分配到堆中

  - 堆：用来存放进程执行中被动态分配的内存段的，他的大小不固定，可动态伸缩
  - 栈：用来存放程序暂时创建的局部变量的，即在函数内部定义的变量或调用函数传入的参数

### 作用域

- 作用域是声明在程序中出现的位置及有效范围

  - 程序编译时，将从当前使用范围开始往最外层查找，如果没有找到报错；如果在内层和外层都存在这个变量，则内层的被优先使用

- 访问权限

  - 包级私有
  - 模块级私有
  - 公开级

## 指针

- 指针就是变量的地址。指针可指向变量值的地址，不是所有的值都有地址，但是所有的变量都有地址。以 ‘&变量名’ 的形式访问变量的地址，比如：&name 表示获取name的内存地址，使用指针时不需要知道变量名就可以读取或更新变量值；通过 *变量名 的形式来获取内存地址的值

```go
var name string = "Forest"

// 获取那么的指针
nickname := &name

// 通过指针获取变量的值
n := *nickname
```

- 内置函数New

  - new(T)可以创建一个未命名的T类型的变量，初始化T类型的零值，并返回 *T
:::tip tip
使用内置函数`new`创建的变量和使用其他方式定义的变量没有什么区别，但是`new(T)`可以直接在表达式中使用，无须提前声明；因此内置函数`new`在语法上更加便利，但它并不是一个基础语法，`new`也不是一个关键字
:::

## 包和文件

- 一个包可以保存一个或者多个以.go结尾的文件，每个包都给包声明了一个独立的命名空间
- 包初始化

  - 包初始化从初始化包级别的变量开始，这些变量是按照声明顺序初始化的，在依赖已经解析完毕就根据依赖的顺序初始化；程序的执行顺序是从上往下执行的；通常使用init(){} 来做包的初始化，这个init函数不能被调用，他是自执行的
  - 我们可以在多个.go文件中使用多个init函数，包的初始化是按照倒入的顺