# 接口

## 接口的定义

接口类型是对其他类型行为的概括与抽象。接口是Go语言最重要的特性之一。接口类型定义了一组方法，但是不包含这些方法的具体实现

接口本质上是一种类型，确切地说，是指针类型。接口可以实现多台功能。如果一个类型实现了某个接口，则所有使用这个接口的地方都支持这种类型的值。接口定义格式如下：

```go
type 接口名称 interface {
  method(参数列表) 返回值列表
  method2(参数列表) 返回值列表
  ...
}
```

如果接口没有方法声明，则它就是一个空接口（`interface{}`）。它的用途类似面向对象里的跟类型，可悲赋值为任何类型的对象。接口变量默认值是`nil`。如果实现接口的类型支持相等运算，则可做相等运算，否则报错。如下示例代码：

```go
package main

import "fmt"

func main() {
	var var1, var2 interface{}
	fmt.Println(var1 == nil, var1 == var2) // true true

	var1, var2 = 66, 88
	fmt.Println(var1 == var2) // false

	var1, var2 = map[string]int{}, map[string]int{}
	fmt.Println(var1 == var2) // 报错
}
```

## 接口的赋值

Go语言的接口不支持直接实例化，但支持赋值操作，从而快速实现接口与实现类的映射。接口赋值在Go语言中氛围两种情况：

- 将实现接口的对象实例赋值给接口
- 将一个接口赋值给另一个接口

### 将实现接口的对象实例赋值给接口

将指定类型的对象实例赋值给接口，要求该对象对应的类实现了接口要求的所有方法，否则就不能算作接口的实现，例如，先定义一个`Num`类型及相关方法：

```
package main

func main() {

}

type Num int

// 相等
func (x Num) Equal(i Num) bool {
	return x == i
}

// 小于
func (x Num) LessThan(i Num) bool {
	return x < i
}

// 大于
func (x Num) MoreThan(i Num) bool {
	return x > i
}

// 乘积
func (x Num) Multiple(i Num) {
	*x = *x * i
}

// 相除
func (x Num) Divide(i Num) {
	*x = *x / i
}
```

然后，相应地定义一个接口`NumI`，使其`Num`类型实现了`NumI`接口

```go
type NumI interface {
	Equal(i Num) bool
	LessThan(i Num) bool
	MoreThan(i Num) bool
	Multiple(i Num)
	Divide(i Num)
}
```

### 将接口赋值给接口

在Go语言中，只要两个接口拥有相同的方法列表（与顺序无关），则他们就是等同的，可以相互赋值。比如下面两个包：

```go
package oop1

type NumInterface1 interface {
  Equal(i int) bool
  LassThan(i int) bool
  BiggerThan(i int) bool
}
```

```go
package oop2

type NumInterface1 interface {
  Equal(i int) bool
  LassThan(i int) bool
  BiggerThan(i int) bool
}
```

上面两段代码只是包名、接口名和顺序不同，在Go语言中，上面两个接口实际上并无区别，因为`oop1`包的`NumInterface1`接口也实现了包名`oop2`的`NumInterface2`的所有方法，任何实现了以上两个接口的其中一个接口，那么就可以赋值给另一个接口

## 接口的查询

接口的查询是在程序运行时进行的。查询成功与否，也要在运行期才能够确定。它不像接口的赋值编译器只需要通过静态类型检查即可判断类型赋值是否可行。在Go语言中，可以询问它指向的对象是否是某个类型，例如：

```go
var filewriter Writer = ...
if file, ok := filewriter.(*File); ok {
  // ...
}
```

